# 개념
    두 개 이상의 프로세스나 스레드가 서로 자원을 기다리면서 무한히 대기하는 상태

# 발생 조건
- 상호 배제
    - 한 자원에 여러 프로세스가 동시에 접근할 수 없다.
- 점유 대기
    - 하나의 자원을 소유한 상태에서 다른 자원을 기다린다.
- 비선점
    - 프로세스가 어떤 자원의 사용을 끝낼 때까지 프로세스의 자원을 뺏을 수 없다.
- 순환 대기
    - 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 갖고 있다.

# 해결 방법
4가지 발생 조건 중 하나라도 제거하면 교착 상태를 막을 수 있다.
공유 자원 중 많은 경우에 한 번에 한 프로세스 혹은 스레드만 접근할 수 있기 때문에 상호 배제 조건은 제거하기 어렵다.

    대부분 교착 상태 방지 알고리즘은 순환 대기가 발생하는 것을 막는데 초점이 맞춰져 있다.


- 예방(Prevention)
    - 교착 상태 조건 중 하나를 제거함으로 데드락이 발생하지 않도록 예방하는 방식
    - 자원 낭비가 심하다.
- 회피(Avoidance)
    - 데드락 발생 가능성을 인정하면서도 적절하게 회피하는 방식
    - 은행원 알고리즘
        - 프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지를 사전에 검사하는 알고리즘
        - 발생하지 않으면 자원을 할당하고, 발생하면 다른 프로세스가 자원을 해제할 때까지 대기한다.
        - 안전상태: 시스템이 교착상태를 일으키지 않으면서 각 프로세스가 요구한 최대 요구량만큼 필요한 자원을 할당해 줄 수 있는 상태
        - 항상 안전 상태를 유지할 수 있다는 장점이 있으나 최대 자원 요구량을 미리 알아야 하고 항상 불안전 상태를 방지해야 하므로 자원 이용도가 낮다.
- 탐지(Detection) 및 회복(Recovery)
    - 은행원 알고리즘과 유사하게 시스템의 자원 할당 상태를 갖고 데드락이 발생했는지 여부를 탐색한다.
    - 탐지했다면 데드락을 회복한다.
        - 데드락 상태의 프로세스 모두 중단시키기
        - 프로세스를 하나씩 중단 시킬 때마다 탐지 알고리즘으로 데드락을 탐지하면서 회복시키기
        - 자원 섬점을 통해 해결하기(교착 상태에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당)


# 데드락의 대표적인 문제 식사하는 철학자 문제(Dining Philosophers)

운영체제의 교착(데드락)상태를 설명하기 위한 문제. 1965년에 에츠허르 다익스트라가 만든 문제이다.
- 맞다 그 알고리즘을 개발한 사람이다.


![image](https://github.com/Ryeohwan/TRL/assets/73810834/9cd256bf-59db-4095-b84b-05fd2a11e356)


    다섯 명의 철학자가 하나의 원탁에 앉아 식사를 한다. 각각의 철학자들 사이에는 포크가 하나씩 있고, 앞에는 접시가 있다. 접시 안에 든 요리는 스파게티 같은 면 요리이기 때문에 식사를 하기 위해서는 동시에 두 개의 포크가 필요하다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없으며, 번갈아가며 각자 식사하거나 생각하는 것만 가능하다. 따라서 식사를 하기 위해서는 왼쪽과 오른쪽의 인접한 철학자가 모두 식사를 하지 않고 생각하고 있어야만 한다. 또한 식사를 마치고 나면, 왼손과 오른손에 든 포크를 다른 철학자가 쓸 수 있도록 내려놓아야 한다. 이 때, 어떤 철학자도 굶지 않고 식사할 수 있도록 하는 방법은 무엇인가?

## 과정은 이렇다.
1. 일정 시간 생각한다.
2. 왼쪽 포크가 사용 가능해질 때까지 대기하고 사용가능하다면 집는다.
3. 오른쪽 포크가 사용 가능해질 때까지 대기하고 사용가능하다면 집는다.
4. 양쪽 포크를 잡으면 일정 시간만큼 식사한다.
5. 오른쪽 포크를 내려놓는다.
6. 왼쪽 포크를 내려놓는다.
7. 1번으로 돌아간다.

모두가 왼쪽 포크를 집게되면 모두 오른쪽 포크를 대기하게 되어 기아 상태가 발생한다.

## 교착상태 조건 성립

- 상호 배제 : 포크는 한 철학자만 사용할 수 있다.
- 점유 대기 : 왼쪽 포크를 집은 상태에서 오른쪽 포크를 기다린다.
- 비선점 : 이미 누군가가 집어든 포크를 강제로 빼앗을 수 없다.
- 순환 대기 : 모든 철학자들이 오른쪽에 앉은 철학자가 포크를 놓기를 기다린다.

## 해결책
- 뮤텍스(화장실이 한개만 있는 식당)
    - 공유된 자원에 하나의 스레드만 접근할 수 있도록 한다.
- 세마포어(화장실이 여러 개인 식당)
    - 철학자 문제를 예시로 들면 철학자는 5명이니 최대 4명만 접근할 수 있도록 한다.

1. 타임아웃 설정. 철학자가 포크를 집고 일정 시간 내에 다른 쪽 포크를 획득하는데 실패(…)한다면, 포크를 반납하게 한다. 가장 간단하지만 타임아웃에 따른 딜레이가 있다.
2. 철학자들 중 하나는 포크를 오른쪽부터 잡게 한다고 생각해 보자. 예를 들어 1번 철학자는 왼쪽부터, 2번 철학자는 오른쪽부터 잡는다. 1번 철학자가 왼쪽 포크만 잡은 상태에서 행동권이 2번 철학자에게 넘어간다고 하더라도, 2번 철학자는 자신의 오른쪽 포크가 현재 사용 불가능하기 때문에, 첫번째 포크를 잡으려는 상황에서 멈춰 있게 된다. 이 상황에서 1번 철학자로 다시 행동권이 넘어오게 되면 1번 철학자는 자신의 오른쪽 포크를 잡고 다시 식사를 할 수 있게 된다.
3. 포크 하나하나에 비교 가능한 고유 값을 부여하여, 고유 값이 높은(또는 낮은) 순서대로 포크를 집게 만든다. 고유 값은 보통 해시를 사용하는 게 일반적이며, 서로 겹치면 안 된다.
예를 들어, 포크 다섯 개의 고유번호가 각각 순서대로 295, 329, 683, 591, 274이고 고유번호가 높은 순서대로 포크를 집는다고 가정하자, 3번 철학자는 3번과 4번 포크를 사용할 텐데, 그 포크들의 값은 683, 591이므로 3번 철학자는 683의 값을 가진 3번 포크를 먼저 집는다. 반대로 1번 철학자는 1번과 2번 포크를 사용할 텐데, 그 포크들의 값은 295, 329이므로 1번 철학자는 329의 값을 가진 2번 포크를 먼저 집는다. 이렇게 하면 절대로 모든 철학자가 하나의 포크를 집고 대기하는 일이 없으므로(a > b > c > d > e > a, 또는 반대일 수는 없으므로) 문제를 해결할 수 있다.
