# 해시 테이블(Hash table)

hash table은 효율적인 탐색(빠른 탐색)을 위한 자료구조로써 key-value쌍의 데이터를 입력받느다. hash function $h$에 key값을 입력으로 넣어 얻은 해시값 $h(k)$를 위치로 지정하여 key- value 데이터 쌍을 저장한다. 따라서 저장, 삭제, 검색의 시간복잡도는 모두 $O(1)$이다.

좋은 hash function의 핵심적인 조건은 해시값이 고르게 분포되게 하는 것이다. 좋은 해시함수를 가져도 **해시충돌(collision)** 은 발생할 수 있다. (비둘기집 원리 - 해시함수의 입력값은 무한하지만, 출력값의 가짓수는 유한하기 때문에 해시 충돌은 반드시 발생한다)

## 해시충돌이 발생했을때 해결 방법?

collision이란 서로 다른 key의 해시값이 똑같을 때를 말한다. 즉, 중복되는 key는 없지만 해시값은 중복될 수 있는데 이 때 collision이 발생했다고 한다.

### 1. 체이닝(Separate Chaining)

체이닝 방식은 Linked List(또는 Tree)를 사용해서 충돌을 해결한다. 충돌이 발생했을때 연결리스트에 노드(slot)을 추가해서 데이터를 저장할 수 있다. 하지만 모든 키값이 하나의 해시값을 가질경우 삼입, 검색, 삭제가 $O(n)$ 의 시간 복잡도가 발생할 수 있다(worst case)

### 2. 개방주소법(Open Addressing)

체이닝의 경우 버켓이 꽉차도 연결리스트를 통해 계속 늘려 나가기 때문에 주소 자체의 변화는 없다 하지만 개방 주소법을 사용할 셩우 주소가 바뀌게 된다. 충돌 이 일어났을 때 개방주소법은 정한 규칙에 따라 비어있는 slot을 찾게 된다. 그 방법은 크게 3가지가 있다.

-   선형탐색
-   제곱탐색
-   이중해시

선형탐색과 제곱탐색을 사용할경우 충돌 횟수가 많아지면 특정 영억에 데이터가 집중적으로 몰리는 클러스터링 현상이 발생해 평균탐색 시간이 기하급수적으로 늘어 날 수 있다.

이중해시는 이런 클러스터링 문제가 발생하는 것을 막고자 두개의 해시 함수를 사용해서 하나는 최초의 핵시값을 얻을때 사용하고 다른 하나는 해시 충돌 발생시 이동폭을 결정한다.
